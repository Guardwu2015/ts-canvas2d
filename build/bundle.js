/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils_application__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/application */ \"./src/utils/application.ts\");\n\nconsole.log('ts', _utils_application__WEBPACK_IMPORTED_MODULE_0__.Canvas2DApplication);\n\n\n//# sourceURL=webpack://react-with-webpack-typescript/./src/index.ts?");

/***/ }),

/***/ "./src/utils/application.ts":
/*!**********************************!*\
  !*** ./src/utils/application.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"EInputEventType\": () => (/* binding */ EInputEventType),\n/* harmony export */   \"CanvasInputEvent\": () => (/* binding */ CanvasInputEvent),\n/* harmony export */   \"CanvasMouseEvent\": () => (/* binding */ CanvasMouseEvent),\n/* harmony export */   \"CanvasKeyBoardEvent\": () => (/* binding */ CanvasKeyBoardEvent),\n/* harmony export */   \"Application\": () => (/* binding */ Application),\n/* harmony export */   \"Canvas2DApplication\": () => (/* binding */ Canvas2DApplication),\n/* harmony export */   \"WebGLApplication\": () => (/* binding */ WebGLApplication)\n/* harmony export */ });\n/* harmony import */ var _math2d__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math2d */ \"./src/utils/math2d.ts\");\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\nvar EInputEventType;\n(function (EInputEventType) {\n    EInputEventType[EInputEventType[\"MOUSEEVENT\"] = 0] = \"MOUSEEVENT\";\n    EInputEventType[EInputEventType[\"MOUSEDOWN\"] = 1] = \"MOUSEDOWN\";\n    EInputEventType[EInputEventType[\"MOUSEUP\"] = 2] = \"MOUSEUP\";\n    EInputEventType[EInputEventType[\"MOUSEMOVE\"] = 3] = \"MOUSEMOVE\";\n    EInputEventType[EInputEventType[\"MOUSEDRAG\"] = 4] = \"MOUSEDRAG\";\n    EInputEventType[EInputEventType[\"KEYBOARDEVENT\"] = 5] = \"KEYBOARDEVENT\";\n    EInputEventType[EInputEventType[\"KEYUP\"] = 6] = \"KEYUP\";\n    EInputEventType[EInputEventType[\"KEYDOWN\"] = 7] = \"KEYDOWN\";\n    EInputEventType[EInputEventType[\"KEYPRESS\"] = 8] = \"KEYPRESS\";\n})(EInputEventType || (EInputEventType = {}));\n;\nvar CanvasInputEvent = /** @class */ (function () {\n    function CanvasInputEvent(type, altKey, ctrlKey, shiftKey) {\n        if (altKey === void 0) { altKey = false; }\n        if (ctrlKey === void 0) { ctrlKey = false; }\n        if (shiftKey === void 0) { shiftKey = false; }\n        this.altKey = altKey;\n        this.ctrlKey = ctrlKey;\n        this.shiftKey = shiftKey;\n        this.type = type;\n    }\n    return CanvasInputEvent;\n}());\n\nvar Timer = /** @class */ (function () {\n    function Timer(callback) {\n        this.id = -1;\n        this.enabled = false;\n        this.callbackData = undefined;\n        this.countdown = 0;\n        this.timeout = 0;\n        this.onlyOnce = false;\n        this.callback = callback;\n    }\n    return Timer;\n}());\nvar CanvasMouseEvent = /** @class */ (function (_super) {\n    __extends(CanvasMouseEvent, _super);\n    function CanvasMouseEvent(type, canvasPos, button, altKey, ctrlKey, shiftKey) {\n        if (altKey === void 0) { altKey = false; }\n        if (ctrlKey === void 0) { ctrlKey = false; }\n        if (shiftKey === void 0) { shiftKey = false; }\n        var _this = _super.call(this, type, altKey, ctrlKey, shiftKey) || this;\n        _this.canvasPosition = canvasPos;\n        _this.button = button;\n        _this.hasLocalPosition = false;\n        _this.localPosition = _math2d__WEBPACK_IMPORTED_MODULE_0__.vec2.create();\n        return _this;\n    }\n    return CanvasMouseEvent;\n}(CanvasInputEvent));\n\nvar CanvasKeyBoardEvent = /** @class */ (function (_super) {\n    __extends(CanvasKeyBoardEvent, _super);\n    function CanvasKeyBoardEvent(type, key, keyCode, repeat, altKey, ctrlKey, shiftKey) {\n        if (altKey === void 0) { altKey = false; }\n        if (ctrlKey === void 0) { ctrlKey = false; }\n        if (shiftKey === void 0) { shiftKey = false; }\n        var _this = _super.call(this, type, altKey, ctrlKey, shiftKey) || this;\n        _this.key = key;\n        _this.keyCode = keyCode;\n        _this.repeat = repeat;\n        return _this;\n    }\n    return CanvasKeyBoardEvent;\n}(CanvasInputEvent));\n\nvar Application = /** @class */ (function () {\n    function Application(canvas) {\n        this.timers = [];\n        this._timeId = -1;\n        this._fps = 0;\n        this._start = false;\n        this._requestId = -1;\n        this.canvas = canvas;\n        this.canvas.addEventListener(\"mousedown\", this, false);\n        this.canvas.addEventListener(\"mouseup\", this, false);\n        this.canvas.addEventListener(\"mousemove\", this, false);\n        window.addEventListener(\"keydown\", this, false);\n        window.addEventListener(\"keyup\", this, false);\n        window.addEventListener(\"keypress\", this, false);\n        this._isMouseDown = false;\n        this.isSupportMouseMove = false;\n    }\n    Application.prototype.isRunning = function () {\n        return this._start;\n    };\n    Object.defineProperty(Application.prototype, \"fps\", {\n        get: function () {\n            return this._fps;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Application.prototype.start = function () {\n        var _this = this;\n        if (!this._start) {\n            this._start = true;\n            this._lastTime = -1;\n            this._startTime = -1;\n            this._requestId = requestAnimationFrame(function (msec) {\n                _this.step(msec);\n            });\n        }\n    };\n    Application.prototype.step = function (timeStamp) {\n        var _this = this;\n        if (this._startTime === -1)\n            this._startTime = timeStamp;\n        if (this._lastTime === -1)\n            this._lastTime = timeStamp;\n        var elapsedMsec = timeStamp - this._startTime;\n        var intervalSec = (timeStamp - this._lastTime);\n        if (intervalSec !== 0) {\n            this._fps = 1000.0 / intervalSec;\n        }\n        intervalSec /= 1000.0;\n        this._lastTime = timeStamp;\n        this._handleTimers(intervalSec);\n        this.update(elapsedMsec, intervalSec);\n        this.render();\n        requestAnimationFrame(function (elapsedMsec) {\n            _this.step(elapsedMsec);\n        });\n    };\n    Application.prototype.stop = function () {\n        if (this._start) {\n            cancelAnimationFrame(this._requestId);\n            this._lastTime = -1;\n            this._startTime = -1;\n            this._start = false;\n        }\n    };\n    Application.prototype.update = function (elapsedMsec, intervalSec) { };\n    Application.prototype.render = function () { };\n    Application.prototype.handleEvent = function (evt) {\n        switch (evt.type) {\n            case \"mousedown\":\n                this._isMouseDown = true;\n                this.dispatchMouseDown(this._toCanvasMouseEvent(evt, EInputEventType.MOUSEDOWN));\n                break;\n            case \"mouseup\":\n                this._isMouseDown = false;\n                this.dispatchMouseUp(this._toCanvasMouseEvent(evt, EInputEventType.MOUSEUP));\n                break;\n            case \"mousemove\":\n                if (this.isSupportMouseMove) {\n                    this.dispatchMouseMove(this._toCanvasMouseEvent(evt, EInputEventType.MOUSEMOVE));\n                }\n                if (this._isMouseDown) {\n                    this.dispatchMouseDrag(this._toCanvasMouseEvent(evt, EInputEventType.MOUSEDRAG));\n                }\n                break;\n            case \"keypress\":\n                this.dispatchKeyPress(this._toCanvasKeyBoardEvent(evt, EInputEventType.KEYPRESS));\n                break;\n            case \"keydown\":\n                this.dispatchKeyDown(this._toCanvasKeyBoardEvent(evt, EInputEventType.KEYDOWN));\n                break;\n            case \"keyup\":\n                this.dispatchKeyUp(this._toCanvasKeyBoardEvent(evt, EInputEventType.KEYUP));\n                break;\n        }\n    };\n    Application.prototype.dispatchMouseDown = function (evt) {\n        return;\n    };\n    Application.prototype.dispatchMouseUp = function (evt) {\n        return;\n    };\n    Application.prototype.dispatchMouseMove = function (evt) {\n        return;\n    };\n    Application.prototype.dispatchMouseDrag = function (evt) {\n        return;\n    };\n    Application.prototype.dispatchKeyDown = function (evt) {\n        return;\n    };\n    Application.prototype.dispatchKeyUp = function (evt) {\n        return;\n    };\n    Application.prototype.dispatchKeyPress = function (evt) {\n        return;\n    };\n    Application.prototype._viewportToCanvasCoordinate = function (evt) {\n        if (this.canvas) {\n            var rect = this.canvas.getBoundingClientRect();\n            if (evt.type === \"mousedown\") {\n                console.log(\" boundingClientRect : \" + JSON.stringify(rect));\n                console.log(\" clientX : \" + evt.clientX + \" clientY : \" + evt.clientY);\n            }\n            if (evt.target) {\n                var borderLeftWidth = 0;\n                var borderTopWidth = 0;\n                var paddingLeft = 0;\n                var paddingTop = 0;\n                var decl = window.getComputedStyle(evt.target);\n                var strNumber = decl.borderLeftWidth;\n                if (strNumber !== null) {\n                    borderLeftWidth = parseInt(strNumber, 10);\n                }\n                if (strNumber !== null) {\n                    borderTopWidth = parseInt(strNumber, 10);\n                }\n                strNumber = decl.paddingLeft;\n                if (strNumber !== null) {\n                    paddingLeft = parseInt(strNumber, 10);\n                }\n                strNumber = decl.paddingTop;\n                if (strNumber !== null) {\n                    paddingTop = parseInt(strNumber, 10);\n                }\n                var x = evt.clientX - rect.left - borderLeftWidth - paddingLeft;\n                var y = evt.clientY - rect.top - borderTopWidth - paddingTop;\n                var pos = _math2d__WEBPACK_IMPORTED_MODULE_0__.vec2.create(x, y);\n                if (evt.type === \"mousedown\") {\n                    console.log(\" borderLeftWidth : \" + borderLeftWidth + \" borderTopWidth : \" + borderTopWidth);\n                    console.log(\" paddingLeft : \" + paddingLeft + \" paddingTop : \" + paddingTop);\n                    console.log(\" 变换后的canvasPosition : \" + pos.toString());\n                }\n                return pos;\n            }\n            alert(\"canvas为null\");\n            throw new Error(\"canvas为null\");\n        }\n        alert(\"evt . target为null\");\n        throw new Error(\"evt . target为null\");\n    };\n    Application.prototype._toCanvasMouseEvent = function (evt, type) {\n        var event = evt;\n        var mousePosition = this._viewportToCanvasCoordinate(event);\n        var canvasMouseEvent = new CanvasMouseEvent(type, mousePosition, event.button, event.altKey, event.ctrlKey, event.shiftKey);\n        return canvasMouseEvent;\n    };\n    Application.prototype._toCanvasKeyBoardEvent = function (evt, type) {\n        var event = evt;\n        var canvasKeyboardEvent = new CanvasKeyBoardEvent(type, event.key, event.keyCode, event.repeat, event.altKey, event.ctrlKey, event.shiftKey);\n        return canvasKeyboardEvent;\n    };\n    Application.prototype.addTimer = function (callback, timeout, onlyOnce, data) {\n        if (timeout === void 0) { timeout = 1.0; }\n        if (onlyOnce === void 0) { onlyOnce = false; }\n        if (data === void 0) { data = undefined; }\n        var timer;\n        var found = false;\n        for (var i = 0; i < this.timers.length; i++) {\n            var timer_1 = this.timers[i];\n            if (timer_1.enabled === false) {\n                timer_1.callback = callback;\n                timer_1.callbackData = data;\n                timer_1.timeout = timeout;\n                timer_1.countdown = timeout;\n                timer_1.enabled = true;\n                timer_1.onlyOnce = onlyOnce;\n                return timer_1.id;\n            }\n        }\n        timer = new Timer(callback);\n        timer.callbackData = data;\n        timer.timeout = timeout;\n        timer.countdown = timeout;\n        timer.enabled = true;\n        timer.id = ++this._timeId;\n        timer.onlyOnce = onlyOnce;\n        this.timers.push(timer);\n        return timer.id;\n    };\n    Application.prototype.removeTimer = function (id) {\n        var found = false;\n        for (var i = 0; i < this.timers.length; i++) {\n            if (this.timers[i].id === id) {\n                var timer = this.timers[i];\n                timer.enabled = false;\n                found = true;\n                break;\n            }\n        }\n        return found;\n    };\n    Application.prototype._handleTimers = function (intervalSec) {\n        for (var i = 0; i < this.timers.length; i++) {\n            var timer = this.timers[i];\n            if (timer.enabled === false) {\n                continue;\n            }\n            timer.countdown -= intervalSec;\n            if (timer.countdown < 0.0) {\n                timer.callback(timer.id, timer.callbackData);\n                if (timer.onlyOnce === false) {\n                    timer.countdown = timer.timeout;\n                }\n                else {\n                    this.removeTimer(timer.id);\n                }\n            }\n        }\n    };\n    return Application;\n}());\n\nvar Canvas2DApplication = /** @class */ (function (_super) {\n    __extends(Canvas2DApplication, _super);\n    function Canvas2DApplication(canvas) {\n        var _this = _super.call(this, canvas) || this;\n        _this.context2D = _this.canvas.getContext(\"2d\");\n        return _this;\n    }\n    return Canvas2DApplication;\n}(Application));\n\nvar WebGLApplication = /** @class */ (function (_super) {\n    __extends(WebGLApplication, _super);\n    function WebGLApplication(canvas, contextAttributes) {\n        var _this = _super.call(this, canvas) || this;\n        _this.context3D = _this.canvas.getContext(\"webgl\", contextAttributes);\n        if (_this.context3D === null) {\n            _this.context3D = _this.canvas.getContext(\"experimental-webgl\", contextAttributes);\n            if (_this.context3D === null) {\n                alert(\" 无法创建WebGLRenderingContext上下文对象 \");\n                throw new Error(\" 无法创建WebGLRenderingContext上下文对象 \");\n            }\n        }\n        return _this;\n    }\n    return WebGLApplication;\n}(Application));\n\n\n\n//# sourceURL=webpack://react-with-webpack-typescript/./src/utils/application.ts?");

/***/ }),

/***/ "./src/utils/math2d.ts":
/*!*****************************!*\
  !*** ./src/utils/math2d.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"vec2\": () => (/* binding */ vec2),\n/* harmony export */   \"vec3\": () => (/* binding */ vec3),\n/* harmony export */   \"mat2d\": () => (/* binding */ mat2d),\n/* harmony export */   \"MatrixStack\": () => (/* binding */ MatrixStack),\n/* harmony export */   \"Math2D\": () => (/* binding */ Math2D),\n/* harmony export */   \"Size\": () => (/* binding */ Size),\n/* harmony export */   \"Rectangle\": () => (/* binding */ Rectangle),\n/* harmony export */   \"Inset\": () => (/* binding */ Inset),\n/* harmony export */   \"Transform2D\": () => (/* binding */ Transform2D),\n/* harmony export */   \"BezierEnumerator\": () => (/* binding */ BezierEnumerator),\n/* harmony export */   \"QuadraticBezierEnumerator\": () => (/* binding */ QuadraticBezierEnumerator)\n/* harmony export */ });\nvar EPSILON = 0.00001;\nvar PiBy180 = 0.017453292519943295;\nvar vec2 = /** @class */ (function () {\n    function vec2(x, y) {\n        if (x === void 0) { x = 0; }\n        if (y === void 0) { y = 0; }\n        this.values = new Float32Array([x, y]);\n    }\n    vec2.prototype.toString = function () {\n        return \" [ \" + this.values[0] + \" , \" + this.values[1] + \" ] \";\n    };\n    Object.defineProperty(vec2.prototype, \"x\", {\n        get: function () { return this.values[0]; },\n        set: function (x) { this.values[0] = x; },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(vec2.prototype, \"y\", {\n        get: function () { return this.values[1]; },\n        set: function (y) { this.values[1] = y; },\n        enumerable: false,\n        configurable: true\n    });\n    vec2.prototype.reset = function (x, y) {\n        if (x === void 0) { x = 0; }\n        this.values[0] = x;\n        this.values[1] = y;\n        return this;\n    };\n    vec2.prototype.equals = function (vector) {\n        if (Math.abs(this.values[0] - vector.values[0]) > EPSILON)\n            return false;\n        if (Math.abs(this.values[1] - vector.values[1]) > EPSILON)\n            return false;\n        return true;\n    };\n    vec2.prototype.negative = function () {\n        this.values[0] = -this.values[0];\n        this.values[1] = -this.values[1];\n        return this;\n    };\n    Object.defineProperty(vec2.prototype, \"squaredLength\", {\n        get: function () {\n            var x = this.values[0];\n            var y = this.values[1];\n            return (x * x + y * y);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(vec2.prototype, \"length\", {\n        get: function () {\n            return Math.sqrt(this.squaredLength);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    vec2.prototype.normalize = function () {\n        var len = this.length;\n        if (Math2D.isEquals(len, 0)) {\n            console.log(\" the length = 0 \");\n            this.values[0] = 0;\n            this.values[1] = 0;\n            return 0;\n        }\n        if (Math2D.isEquals(len, 1)) {\n            console.log(\" the length = 1 \");\n            return 1.0;\n        }\n        this.values[0] /= len;\n        this.values[1] /= len;\n        return len;\n    };\n    vec2.create = function (x, y) {\n        if (x === void 0) { x = 0; }\n        if (y === void 0) { y = 0; }\n        return new vec2(x, y);\n    };\n    vec2.prototype.add = function (right) {\n        vec2.sum(this, right, this);\n        return this;\n    };\n    vec2.sum = function (left, right, result) {\n        if (result === void 0) { result = null; }\n        if (result === null)\n            result = new vec2();\n        result.values[0] = left.values[0] + right.values[0];\n        result.values[1] = left.values[1] + right.values[1];\n        return result;\n    };\n    vec2.prototype.substract = function (another) {\n        vec2.difference(this, another, this);\n        return this;\n    };\n    vec2.difference = function (end, start, result) {\n        if (result === void 0) { result = null; }\n        if (result === null)\n            result = new vec2();\n        result.values[0] = end.values[0] - start.values[0];\n        result.values[1] = end.values[1] - start.values[1];\n        return result;\n    };\n    vec2.copy = function (src, result) {\n        if (result === void 0) { result = null; }\n        if (result === null)\n            result = new vec2();\n        result.values[0] = src.values[0];\n        result.values[1] = src.values[1];\n        return result;\n    };\n    vec2.scale = function (direction, scalar, result) {\n        if (result === void 0) { result = null; }\n        if (result === null)\n            result = new vec2();\n        result.values[0] = direction.values[0] * scalar;\n        result.values[1] = direction.values[1] * scalar;\n        return result;\n    };\n    vec2.scaleAdd = function (start, direction, scalar, result) {\n        if (result === void 0) { result = null; }\n        if (result === null)\n            result = new vec2();\n        vec2.scale(direction, scalar, result);\n        return vec2.sum(start, result, result);\n    };\n    vec2.moveTowards = function (start, direction, scalar, result) {\n        if (result === void 0) { result = null; }\n        if (result === null)\n            result = new vec2();\n        vec2.scale(direction, scalar, result);\n        return vec2.sum(start, result, result);\n    };\n    vec2.prototype.innerProduct = function (right) {\n        return vec2.dotProduct(this, right);\n    };\n    vec2.dotProduct = function (left, right) {\n        return left.values[0] * right.values[0] + left.values[1] * right.values[1];\n    };\n    vec2.crossProduct = function (left, right) {\n        return left.x * right.y - left.y * right.x;\n    };\n    vec2.getOrientation = function (from, to, isRadian) {\n        if (isRadian === void 0) { isRadian = false; }\n        var diff = vec2.difference(to, from);\n        var radian = Math.atan2(diff.y, diff.x);\n        if (isRadian === false) {\n            radian = Math2D.toDegree(radian);\n        }\n        return radian;\n    };\n    vec2.getAngle = function (a, b, isRadian) {\n        if (isRadian === void 0) { isRadian = false; }\n        var dot = vec2.dotProduct(a, b);\n        var radian = Math.acos(dot / (a.length * b.length));\n        if (isRadian === false) {\n            radian = Math2D.toDegree(radian);\n        }\n        return radian;\n    };\n    vec2.cosAngle = function (a, b, norm) {\n        if (norm === void 0) { norm = false; }\n        if (norm === true) {\n            a.normalize();\n            b.normalize();\n        }\n        return vec2.dotProduct(a, b);\n    };\n    vec2.sinAngle = function (a, b, norm) {\n        if (norm === void 0) { norm = false; }\n        if (norm === true) {\n            a.normalize();\n            b.normalize();\n        }\n        return (a.x * b.y - b.x * a.y);\n    };\n    vec2.zero = new vec2(0, 0);\n    vec2.xAxis = new vec2(1, 0);\n    vec2.yAxis = new vec2(0, 1);\n    vec2.nXAxis = new vec2(-1, 0);\n    vec2.nYAxis = new vec2(0, -1);\n    vec2.temp = new vec2(0, 0);\n    vec2.temp1 = new vec2(0, 0);\n    return vec2;\n}());\n\nvar vec3 = /** @class */ (function () {\n    function vec3(x, y, z) {\n        if (x === void 0) { x = 0; }\n        if (y === void 0) { y = 0; }\n        if (z === void 0) { z = 0; }\n        this.values = new Float32Array([x, y, z]);\n    }\n    Object.defineProperty(vec3.prototype, \"x\", {\n        get: function () { return this.values[0]; },\n        set: function (x) { this.values[0] = x; },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(vec3.prototype, \"y\", {\n        get: function () { return this.values[1]; },\n        set: function (y) { this.values[1] = y; },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(vec3.prototype, \"z\", {\n        get: function () { return this.values[2]; },\n        set: function (z) { this.values[2] = z; },\n        enumerable: false,\n        configurable: true\n    });\n    vec3.cross = function (v1, v2, out) {\n        if (out === void 0) { out = null; }\n        if (out === null)\n            out = new vec3();\n        out.x = v1.y * v2.z - v1.z * v2.y;\n        out.y = v1.z * v2.x - v1.x * v2.z;\n        out.z = v1.x * v2.y - v1.y * v2.x;\n        return out;\n    };\n    vec3.prototype.toString = function () {\n        return \" [ \" + this.values[0] + \" , \" + this.values[1] + \" , \" + this.values[2] + \" ] \";\n    };\n    return vec3;\n}());\n\nvar mat2d = /** @class */ (function () {\n    function mat2d(a, b, c, d, x, y) {\n        if (a === void 0) { a = 1; }\n        if (b === void 0) { b = 0; }\n        if (c === void 0) { c = 0; }\n        if (d === void 0) { d = 1; }\n        if (x === void 0) { x = 0; }\n        if (y === void 0) { y = 0; }\n        this.values = new Float32Array([a, b, c, d, x, y]);\n    }\n    mat2d.prototype.identity = function () {\n        this.values[0] = 1.0;\n        this.values[1] = 0.0;\n        this.values[2] = 0.0;\n        this.values[3] = 1.0;\n        this.values[4] = 0.0;\n        this.values[5] = 0.0;\n    };\n    mat2d.create = function (a, b, c, d, x, y) {\n        if (a === void 0) { a = 1; }\n        if (b === void 0) { b = 0; }\n        if (c === void 0) { c = 0; }\n        if (d === void 0) { d = 1; }\n        if (x === void 0) { x = 0; }\n        if (y === void 0) { y = 0; }\n        return new mat2d(a, b, c, d, x, y);\n    };\n    Object.defineProperty(mat2d.prototype, \"xAxis\", {\n        get: function () {\n            return vec2.create(this.values[0], this.values[1]);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(mat2d.prototype, \"yAxis\", {\n        get: function () {\n            return vec2.create(this.values[2], this.values[3]);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(mat2d.prototype, \"origin\", {\n        get: function () {\n            return vec2.create(this.values[4], this.values[5]);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    mat2d.prototype.getAngle = function (isRadian) {\n        if (isRadian === void 0) { isRadian = false; }\n        var angle = Math.atan2(this.values[1], this.values[0]);\n        if (isRadian) {\n            return angle;\n        }\n        return angle / PiBy180;\n    };\n    mat2d.copy = function (src, result) {\n        if (result === void 0) { result = null; }\n        if (result === null)\n            result = new mat2d();\n        result.values[0] = src.values[0];\n        result.values[1] = src.values[1];\n        result.values[2] = src.values[2];\n        result.values[3] = src.values[3];\n        result.values[4] = src.values[4];\n        result.values[5] = src.values[5];\n        return result;\n    };\n    mat2d.multiply = function (left, right, result) {\n        if (result === void 0) { result = null; }\n        if (result === null)\n            result = new mat2d();\n        var a0 = left.values[0];\n        var a1 = left.values[1];\n        var a2 = left.values[2];\n        var a3 = left.values[3];\n        var a4 = left.values[4];\n        var a5 = left.values[5];\n        var b0 = right.values[0];\n        var b1 = right.values[1];\n        var b2 = right.values[2];\n        var b3 = right.values[3];\n        var b4 = right.values[4];\n        var b5 = right.values[5];\n        result.values[0] = a0 * b0 + a2 * b1;\n        result.values[1] = a1 * b0 + a3 * b1;\n        result.values[2] = a0 * b2 + a2 * b3;\n        result.values[3] = a1 * b2 + a3 * b3;\n        result.values[4] = a0 * b4 + a2 * b5 + a4;\n        result.values[5] = a1 * b4 + a3 * b5 + a5;\n        return result;\n    };\n    mat2d.determinant = function (mat) {\n        return mat.values[0] * mat.values[3] - mat.values[2] * mat.values[1];\n    };\n    mat2d.invert = function (src, result) {\n        var det = mat2d.determinant(src);\n        if (Math2D.isEquals(det, 0)) {\n            return false;\n        }\n        det = 1.0 / det;\n        result.values[0] = src.values[3] * det;\n        result.values[1] = -src.values[1] * det;\n        result.values[2] = -src.values[2] * det;\n        result.values[3] = src.values[0] * det;\n        result.values[4] = (src.values[2] * src.values[5] - src.values[3] * src.values[4]) * det;\n        result.values[5] = (src.values[1] * src.values[4] - src.values[0] * src.values[5]) * det;\n        return true;\n    };\n    mat2d.makeRotation = function (radians, result) {\n        if (result === void 0) { result = null; }\n        if (result === null)\n            result = new mat2d();\n        var s = Math.sin(radians), c = Math.cos(radians);\n        result.values[0] = c;\n        result.values[1] = s;\n        result.values[2] = -s;\n        result.values[3] = c;\n        result.values[4] = 0;\n        result.values[5] = 0;\n        return result;\n    };\n    mat2d.prototype.onlyRotationMatrixInvert = function () {\n        var s = this.values[1];\n        this.values[1] = this.values[2];\n        this.values[2] = s;\n        return this;\n    };\n    mat2d.makeRotationFromVectors = function (v1, v2, norm, result) {\n        if (norm === void 0) { norm = false; }\n        if (result === void 0) { result = null; }\n        if (result === null)\n            result = new mat2d();\n        result.values[0] = vec2.cosAngle(v1, v2, norm);\n        result.values[1] = vec2.sinAngle(v1, v2, norm);\n        result.values[2] = -vec2.sinAngle(v1, v2, norm);\n        result.values[3] = vec2.cosAngle(v1, v2, norm);\n        result.values[4] = 0;\n        result.values[5] = 0;\n        return result;\n    };\n    mat2d.makeReflection = function (axis, result) {\n        if (result === void 0) { result = null; }\n        if (result === null)\n            result = new mat2d();\n        result.values[0] = 1 - 2 * axis.x * axis.x;\n        result.values[1] = -2 * axis.x * axis.y;\n        result.values[2] = -2 * axis.x * axis.y;\n        result.values[3] = 1 - 2 * axis.y * axis.y;\n        result.values[4] = 0;\n        result.values[5] = 0;\n        return result;\n    };\n    mat2d.makeXSkew = function (sx, result) {\n        if (result === void 0) { result = null; }\n        if (result === null)\n            result = new mat2d();\n        result.values[0] = 1;\n        result.values[1] = 0;\n        result.values[2] = sx;\n        result.values[3] = 1;\n        result.values[4] = 0;\n        result.values[5] = 0;\n        return result;\n    };\n    mat2d.makeYSkew = function (sy, result) {\n        if (result === void 0) { result = null; }\n        if (result === null)\n            result = new mat2d();\n        result.values[0] = 1;\n        result.values[1] = sy;\n        result.values[2] = 0;\n        result.values[3] = 1;\n        result.values[4] = 0;\n        result.values[5] = 0;\n        return result;\n    };\n    mat2d.makeTranslation = function (tx, ty, result) {\n        if (result === void 0) { result = null; }\n        if (result === null)\n            result = new mat2d();\n        result.values[0] = 1;\n        result.values[1] = 0;\n        result.values[2] = 0;\n        result.values[3] = 1;\n        result.values[4] = tx;\n        result.values[5] = ty;\n        return result;\n    };\n    mat2d.makeScale = function (sx, sy, result) {\n        if (result === void 0) { result = null; }\n        if (Math2D.isEquals(sx, 0) || Math2D.isEquals(sy, 0)) {\n            alert(\" x轴或y轴缩放系数为0 \");\n            throw new Error(\" x轴或y轴缩放系数为0 \");\n        }\n        if (result === null)\n            result = new mat2d();\n        result.values[0] = sx;\n        result.values[1] = 0;\n        result.values[2] = 0;\n        result.values[3] = sy;\n        result.values[4] = 0;\n        result.values[5] = 0;\n        return result;\n    };\n    mat2d.temp1 = mat2d.create();\n    mat2d.temp2 = mat2d.create();\n    mat2d.quadBezierBasicMatrix = mat2d.create(1, -2, -2, 2, 1, 0);\n    return mat2d;\n}());\n\nvar MatrixStack = /** @class */ (function () {\n    function MatrixStack() {\n        this._mats = [];\n        this._mats.push(new mat2d());\n    }\n    Object.defineProperty(MatrixStack.prototype, \"matrix\", {\n        get: function () {\n            if (this._mats.length === 0) {\n                alert(\" 矩阵堆栈为空 \");\n                throw new Error(\" 矩阵堆栈为空 \");\n            }\n            return this._mats[this._mats.length - 1];\n        },\n        enumerable: false,\n        configurable: true\n    });\n    MatrixStack.prototype.pushMatrix = function () {\n        var mat = mat2d.copy(this.matrix);\n        this._mats.push(mat);\n    };\n    MatrixStack.prototype.popMatrix = function () {\n        if (this._mats.length === 0) {\n            alert(\" 矩阵堆栈为空 \");\n            return;\n        }\n        this._mats.pop();\n    };\n    MatrixStack.prototype.loadIdentity = function () {\n        this.matrix.identity();\n    };\n    MatrixStack.prototype.loadMatrix = function (mat) {\n        mat2d.copy(mat, this.matrix);\n    };\n    MatrixStack.prototype.multMatrix = function (mat) {\n        mat2d.multiply(this.matrix, mat, this.matrix);\n    };\n    MatrixStack.prototype.translate = function (x, y) {\n        if (x === void 0) { x = 0; }\n        if (y === void 0) { y = 0; }\n        var mat = mat2d.makeTranslation(x, y);\n        this.multMatrix(mat);\n    };\n    MatrixStack.prototype.rotate = function (degree, isRadian) {\n        if (degree === void 0) { degree = 0; }\n        if (isRadian === void 0) { isRadian = false; }\n        if (isRadian === false) {\n            degree = Math2D.toRadian(degree);\n        }\n        var mat = mat2d.makeRotation(degree);\n        this.multMatrix(mat);\n    };\n    MatrixStack.prototype.rotateFrom = function (v1, v2, norm) {\n        if (norm === void 0) { norm = false; }\n        var mat = mat2d.makeRotationFromVectors(v1, v2, norm);\n        this.multMatrix(mat);\n    };\n    MatrixStack.prototype.scale = function (x, y) {\n        if (x === void 0) { x = 1.0; }\n        if (y === void 0) { y = 1.0; }\n        var mat = mat2d.makeScale(x, y);\n        this.multMatrix(mat);\n    };\n    MatrixStack.prototype.invert = function () {\n        var ret = new mat2d();\n        if (mat2d.invert(this.matrix, ret) === false) {\n            alert(\" 堆栈顶部矩阵为奇异矩阵，无法求逆 \");\n            throw new Error(\" 堆栈顶部矩阵为奇异矩阵，无法求逆 \");\n        }\n        return ret;\n    };\n    return MatrixStack;\n}());\n\nvar Math2D = /** @class */ (function () {\n    function Math2D() {\n    }\n    Math2D.toRadian = function (degree) {\n        return degree * PiBy180;\n    };\n    Math2D.toDegree = function (radian) {\n        return radian / PiBy180;\n    };\n    Math2D.random = function (from, to) {\n        return Math.random() * to + from;\n    };\n    Math2D.angleSubtract = function (from, to) {\n        var diff = to - from;\n        while (diff > 180) {\n            diff -= 360;\n        }\n        while (diff < -180) {\n            diff += 360;\n        }\n        return diff;\n    };\n    Math2D.isEquals = function (left, right, espilon) {\n        if (espilon === void 0) { espilon = EPSILON; }\n        if (Math.abs(left - right) >= EPSILON) {\n            return false;\n        }\n        return true;\n    };\n    Math2D.getQuadraticBezierPosition = function (start, ctrl, end, t) {\n        if (t < 0.0 || t > 1.0) {\n            alert(\" t的取值范围必须为[ 0 , 1 ] \");\n            throw new Error(\" t的取值范围必须为[ 0 , 1 ] \");\n        }\n        var t1 = 1.0 - t;\n        var t2 = t1 * t1;\n        return t2 * start + 2.0 * t * t1 * ctrl + t * t * end;\n    };\n    Math2D.getQuadraticBezierVector = function (start, ctrl, end, t, result) {\n        if (result === void 0) { result = null; }\n        if (result === null)\n            result = vec2.create();\n        result.x = Math2D.getQuadraticBezierPosition(start.x, ctrl.x, end.x, t);\n        result.y = Math2D.getQuadraticBezierPosition(start.y, ctrl.y, end.y, t);\n        return result;\n    };\n    Math2D.getQuadraticBezierMat = function (start, ctrl, end, t, result) {\n        if (result === void 0) { result = null; }\n        if (result === null)\n            result = vec2.create();\n        return result;\n    };\n    Math2D.getCubicBezierPosition = function (start, ctrl0, ctrl1, end, t) {\n        if (t < 0.0 || t > 1.0) {\n            alert(\" t的取值范围必须为[ 0 , 1 ] \");\n            throw new Error(\" t的取值范围必须为[ 0 , 1 ] \");\n        }\n        var t1 = (1.0 - t);\n        var t2 = t * t;\n        var t3 = t2 * t;\n        return (t1 * t1 * t1) * start + 3 * t * (t1 * t1) * ctrl0 + (3 * t2 * t1) * ctrl1 + t3 * end;\n    };\n    Math2D.getCubicBezierVector = function (start, ctrl0, ctrl1, end, t, result) {\n        if (result === void 0) { result = null; }\n        if (result === null)\n            result = vec2.create();\n        result.x = Math2D.getCubicBezierPosition(start.x, ctrl0.x, ctrl1.x, end.x, t);\n        result.y = Math2D.getCubicBezierPosition(start.y, ctrl0.y, ctrl1.y, end.y, t);\n        return result;\n    };\n    Math2D.createQuadraticBezierEnumerator = function (start, ctrl, end, steps) {\n        if (steps === void 0) { steps = 30; }\n        return new BezierEnumerator(start, end, ctrl, null, steps);\n    };\n    Math2D.createCubicBezierEnumerator = function (start, ctrl0, ctrl1, end, steps) {\n        if (steps === void 0) { steps = 30; }\n        return new BezierEnumerator(start, end, ctrl0, ctrl1, steps);\n    };\n    Math2D.projectPointOnLineSegment = function (pt, start, end, closePoint) {\n        var v0 = vec2.create();\n        var v1 = vec2.create();\n        var d = 0;\n        vec2.difference(pt, start, v0);\n        vec2.difference(end, start, v1);\n        d = v1.normalize();\n        var t = vec2.dotProduct(v0, v1);\n        if (t < 0) {\n            closePoint.x = start.x;\n            closePoint.y = start.y;\n            return false;\n        }\n        else if (t > d) {\n            closePoint.x = end.x;\n            closePoint.y = end.y;\n            return false;\n        }\n        else {\n            vec2.scaleAdd(start, v1, t, closePoint);\n            return true;\n        }\n    };\n    Math2D.isPointOnLineSegment = function (pt, start, end, radius) {\n        if (radius === void 0) { radius = 2; }\n        var closePt = vec2.create();\n        if (Math2D.projectPointOnLineSegment(pt, start, end, closePt) === false) {\n            return false;\n        }\n        return Math2D.isPointInCircle(pt, closePt, radius);\n    };\n    Math2D.isPointInCircle = function (pt, center, radius) {\n        var diff = vec2.difference(pt, center);\n        var len2 = diff.squaredLength;\n        if (len2 <= radius * radius) {\n            return true;\n        }\n        return false;\n    };\n    Math2D.isPointInRect = function (ptX, ptY, x, y, w, h) {\n        if (ptX >= x && ptX <= x + w && ptY >= y && ptY <= y + h) {\n            return true;\n        }\n        return false;\n    };\n    Math2D.isPointInEllipse = function (ptX, ptY, centerX, centerY, radiusX, radiusY) {\n        var diffX = ptX - centerX;\n        var diffY = ptY - centerY;\n        var n = (diffX * diffX) / (radiusX * radiusX) + (diffY * diffY) / (radiusY * radiusY);\n        return n <= 1.0;\n    };\n    Math2D.sign = function (v0, v1, v2) {\n        var e1 = vec2.difference(v0, v2);\n        var e2 = vec2.difference(v1, v2);\n        return vec2.crossProduct(e1, e2);\n    };\n    Math2D.isPointInTriangle = function (pt, v0, v1, v2) {\n        var b1 = Math2D.sign(v0, v1, pt) < 0.0;\n        var b2 = Math2D.sign(v1, v2, pt) < 0.0;\n        var b3 = Math2D.sign(v2, v0, pt) < 0.0;\n        return ((b1 === b2) && (b2 === b3));\n    };\n    Math2D.isPointInPolygon = function (pt, points) {\n        if (points.length < 3) {\n            return false;\n        }\n        for (var i = 2; i < points.length; i++) {\n            if (Math2D.isPointInTriangle(pt, points[0], points[i - 1], points[i])) {\n                return true;\n            }\n        }\n        return false;\n    };\n    Math2D.isConvex = function (points) {\n        var sign = Math2D.sign(points[0], points[1], points[2]) < 0;\n        var j, k;\n        for (var i = 1; i < points.length; i++) {\n            j = (i + 1) % points.length;\n            k = (i + 2) % points.length;\n            if (sign !== Math2D.sign(points[i], points[j], points[k]) < 0) {\n                return false;\n            }\n        }\n        return true;\n    };\n    Math2D.transform = function (mat, pt, result) {\n        if (result === void 0) { result = null; }\n        if (result === null)\n            result = vec2.create();\n        result.values[0] = mat.values[0] * pt.values[0] + mat.values[2] * pt.values[1] + mat.values[4];\n        result.values[1] = mat.values[1] * pt.values[0] + mat.values[3] * pt.values[1] + mat.values[5];\n        return result;\n    };\n    Math2D.matStack = new MatrixStack();\n    return Math2D;\n}());\n\nvar Size = /** @class */ (function () {\n    function Size(w, h) {\n        if (w === void 0) { w = 1; }\n        if (h === void 0) { h = 1; }\n        this.values = new Float32Array([w, h]);\n    }\n    Object.defineProperty(Size.prototype, \"width\", {\n        get: function () { return this.values[0]; },\n        set: function (value) { this.values[0] = value; },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Size.prototype, \"height\", {\n        get: function () { return this.values[1]; },\n        set: function (value) { this.values[1] = value; },\n        enumerable: false,\n        configurable: true\n    });\n    Size.create = function (w, h) {\n        if (w === void 0) { w = 1; }\n        if (h === void 0) { h = 1; }\n        return new Size(w, h);\n    };\n    return Size;\n}());\n\nvar Rectangle = /** @class */ (function () {\n    function Rectangle(orign, size) {\n        if (orign === void 0) { orign = new vec2(); }\n        if (size === void 0) { size = new Size(1, 1); }\n        this.origin = orign;\n        this.size = size;\n    }\n    Rectangle.prototype.isEmpty = function () {\n        var area = this.size.width * this.size.height;\n        if (Math2D.isEquals(area, 0) === true) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    };\n    Rectangle.create = function (x, y, w, h) {\n        if (x === void 0) { x = 0; }\n        if (y === void 0) { y = 0; }\n        if (w === void 0) { w = 1; }\n        if (h === void 0) { h = 1; }\n        var origin = new vec2(x, y);\n        var size = new Size(w, h);\n        return new Rectangle(origin, size);\n    };\n    return Rectangle;\n}());\n\nvar Inset = /** @class */ (function () {\n    function Inset(l, t, r, b) {\n        if (l === void 0) { l = 0; }\n        if (t === void 0) { t = 0; }\n        if (r === void 0) { r = 0; }\n        if (b === void 0) { b = 0; }\n        this.values = new Float32Array([l, t, r, b]);\n    }\n    Object.defineProperty(Inset.prototype, \"leftMargin\", {\n        get: function () {\n            return this.values[0];\n        },\n        set: function (value) {\n            this.values[0] = value;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Inset.prototype, \"topMargin\", {\n        get: function () {\n            return this.values[1];\n        },\n        set: function (value) {\n            this.values[1] = value;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Inset.prototype, \"rightMargin\", {\n        get: function () {\n            return this.values[2];\n        },\n        set: function (value) {\n            this.values[2] = value;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Inset.prototype, \"bottomMargin\", {\n        get: function () {\n            return this.values[3];\n        },\n        set: function (value) {\n            this.values[3] = value;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return Inset;\n}());\n\nvar Transform2D = /** @class */ (function () {\n    function Transform2D(x, y, rotation, scaleX, scaleY) {\n        if (x === void 0) { x = 0; }\n        if (y === void 0) { y = 0; }\n        if (rotation === void 0) { rotation = 0; }\n        if (scaleX === void 0) { scaleX = 1; }\n        if (scaleY === void 0) { scaleY = 1; }\n        this.position = new vec2(x, y);\n        this.rotation = rotation;\n        this.scale = new vec2(scaleX, scaleY);\n    }\n    Transform2D.prototype.toMatrix = function () {\n        Math2D.matStack.loadIdentity();\n        Math2D.matStack.translate(this.position.x, this.position.y);\n        Math2D.matStack.rotate(this.rotation, false);\n        Math2D.matStack.scale(this.scale.x, this.scale.y);\n        return Math2D.matStack.matrix;\n    };\n    Transform2D.prototype.toInvMatrix = function (result) {\n        var mat = this.toMatrix();\n        return mat2d.invert(mat, result);\n    };\n    return Transform2D;\n}());\n\nvar BezierEnumerator = /** @class */ (function () {\n    function BezierEnumerator(start, end, control0, control1, steps) {\n        if (control1 === void 0) { control1 = null; }\n        if (steps === void 0) { steps = 30; }\n        this._startAnchorPoint = start;\n        this._endAnchorPoint = end;\n        this._controlPoint0 = control0;\n        if (control1 !== null) {\n            this._controlPoint1 = control1;\n        }\n        else {\n            this._controlPoint1 = null;\n        }\n        this._steps = steps;\n        this._i = 1.0 / (this._steps);\n        this._currentIdx = -1;\n    }\n    BezierEnumerator.prototype.reset = function () {\n        this._currentIdx = -1;\n    };\n    Object.defineProperty(BezierEnumerator.prototype, \"current\", {\n        get: function () {\n            if (this._controlPoint1 !== null) {\n                return Math2D.getCubicBezierVector(this._startAnchorPoint, this._controlPoint0, this._controlPoint1, this._endAnchorPoint, this._currentIdx * this._i);\n            }\n            else {\n                return Math2D.getQuadraticBezierVector(this._startAnchorPoint, this._controlPoint0, this._endAnchorPoint, this._currentIdx * this._i);\n            }\n        },\n        enumerable: false,\n        configurable: true\n    });\n    BezierEnumerator.prototype.moveNext = function () {\n        this._currentIdx++;\n        return this._currentIdx < this._steps;\n    };\n    Object.defineProperty(BezierEnumerator.prototype, \"steps\", {\n        get: function () {\n            this._i = 1.0 / (this._steps);\n            return this._steps;\n        },\n        set: function (steps) {\n            this._steps = steps;\n            this.reset();\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return BezierEnumerator;\n}());\n\nvar QuadraticBezierEnumerator = /** @class */ (function () {\n    function QuadraticBezierEnumerator(start, end, control0, steps) {\n        if (steps === void 0) { steps = 30; }\n        this._startAnchorPoint = start;\n        this._endAnchorPoint = end;\n        this._controlPoint0 = control0;\n        this._steps = steps;\n        this._i = 1.0 / (this._steps);\n        this._currentIdx = -1;\n    }\n    QuadraticBezierEnumerator.prototype.reset = function () {\n        this._currentIdx = -1;\n    };\n    Object.defineProperty(QuadraticBezierEnumerator.prototype, \"current\", {\n        get: function () {\n            var t = this._currentIdx * this._i;\n            var ret = vec2.create(t * t, t);\n            Math2D.transform(mat2d.quadBezierBasicMatrix, ret, ret);\n            ret.x = this._startAnchorPoint.x * ret.x + this._controlPoint0.x * ret.y + this._endAnchorPoint.x;\n            ret.y = this._startAnchorPoint.y * ret.x + this._controlPoint0.y * ret.y + this._endAnchorPoint.y;\n            return ret;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    QuadraticBezierEnumerator.prototype.moveNext = function () {\n        this._currentIdx++;\n        return this._currentIdx < this._steps;\n    };\n    Object.defineProperty(QuadraticBezierEnumerator.prototype, \"steps\", {\n        get: function () {\n            this._i = 1.0 / (this._steps);\n            return this._steps;\n        },\n        set: function (steps) {\n            this._steps = steps;\n            this.reset();\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return QuadraticBezierEnumerator;\n}());\n\n\n\n//# sourceURL=webpack://react-with-webpack-typescript/./src/utils/math2d.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	
/******/ })()
;